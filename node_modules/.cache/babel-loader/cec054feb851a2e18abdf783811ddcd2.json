{"ast":null,"code":"import { noopReturn, defaults, isEasingGenerator, isEasingList, interpolate } from '@motionone/utils';\nimport { getEasingFunction } from './utils/easing.es.js';\n\nclass Animation {\n  constructor(output) {\n    let keyframes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 1];\n    let {\n      easing,\n      duration: initialDuration = defaults.duration,\n      delay = defaults.delay,\n      endDelay = defaults.endDelay,\n      repeat = defaults.repeat,\n      offset,\n      direction = \"normal\"\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.startTime = null;\n    this.rate = 1;\n    this.t = 0;\n    this.cancelTimestamp = null;\n    this.easing = noopReturn;\n    this.duration = 0;\n    this.totalDuration = 0;\n    this.repeat = 0;\n    this.playState = \"idle\";\n    this.finished = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n    easing = easing || defaults.easing;\n\n    if (isEasingGenerator(easing)) {\n      const custom = easing.createAnimation(keyframes, () => \"0\", true);\n      easing = custom.easing;\n      if (custom.keyframes !== undefined) keyframes = custom.keyframes;\n      if (custom.duration !== undefined) initialDuration = custom.duration;\n    }\n\n    this.repeat = repeat;\n    this.easing = isEasingList(easing) ? noopReturn : getEasingFunction(easing);\n    this.updateDuration(initialDuration);\n    const interpolate$1 = interpolate(keyframes, offset, isEasingList(easing) ? easing.map(getEasingFunction) : noopReturn);\n\n    this.tick = timestamp => {\n      var _a; // TODO: Temporary fix for OptionsResolver typing\n\n\n      delay = delay;\n      let t = 0;\n\n      if (this.pauseTime !== undefined) {\n        t = this.pauseTime;\n      } else {\n        t = (timestamp - this.startTime) * this.rate;\n      }\n\n      this.t = t; // Convert to seconds\n\n      t /= 1000; // Rebase on delay\n\n      t = Math.max(t - delay, 0);\n      /**\r\n       * If this animation has finished, set the current time\r\n       * to the total duration.\r\n       */\n\n      if (this.playState === \"finished\" && this.pauseTime === undefined) {\n        t = this.totalDuration;\n      }\n      /**\r\n       * Get the current progress (0-1) of the animation. If t is >\r\n       * than duration we'll get values like 2.5 (midway through the\r\n       * third iteration)\r\n       */\n\n\n      const progress = t / this.duration; // TODO progress += iterationStart\n\n      /**\r\n       * Get the current iteration (0 indexed). For instance the floor of\r\n       * 2.5 is 2.\r\n       */\n\n      let currentIteration = Math.floor(progress);\n      /**\r\n       * Get the current progress of the iteration by taking the remainder\r\n       * so 2.5 is 0.5 through iteration 2\r\n       */\n\n      let iterationProgress = progress % 1.0;\n\n      if (!iterationProgress && progress >= 1) {\n        iterationProgress = 1;\n      }\n      /**\r\n       * If iteration progress is 1 we count that as the end\r\n       * of the previous iteration.\r\n       */\n\n\n      iterationProgress === 1 && currentIteration--;\n      /**\r\n       * Reverse progress if we're not running in \"normal\" direction\r\n       */\n\n      const iterationIsOdd = currentIteration % 2;\n\n      if (direction === \"reverse\" || direction === \"alternate\" && iterationIsOdd || direction === \"alternate-reverse\" && !iterationIsOdd) {\n        iterationProgress = 1 - iterationProgress;\n      }\n\n      const p = t >= this.totalDuration ? 1 : Math.min(iterationProgress, 1);\n      const latest = interpolate$1(this.easing(p));\n      output(latest);\n      const isAnimationFinished = this.pauseTime === undefined && (this.playState === \"finished\" || t >= this.totalDuration + endDelay);\n\n      if (isAnimationFinished) {\n        this.playState = \"finished\";\n        (_a = this.resolve) === null || _a === void 0 ? void 0 : _a.call(this, latest);\n      } else if (this.playState !== \"idle\") {\n        this.frameRequestId = requestAnimationFrame(this.tick);\n      }\n    };\n\n    this.play();\n  }\n\n  play() {\n    const now = performance.now();\n    this.playState = \"running\";\n\n    if (this.pauseTime !== undefined) {\n      this.startTime = now - this.pauseTime;\n    } else if (!this.startTime) {\n      this.startTime = now;\n    }\n\n    this.cancelTimestamp = this.startTime;\n    this.pauseTime = undefined;\n    this.frameRequestId = requestAnimationFrame(this.tick);\n  }\n\n  pause() {\n    this.playState = \"paused\";\n    this.pauseTime = this.t;\n  }\n\n  finish() {\n    this.playState = \"finished\";\n    this.tick(0);\n  }\n\n  stop() {\n    var _a;\n\n    this.playState = \"idle\";\n\n    if (this.frameRequestId !== undefined) {\n      cancelAnimationFrame(this.frameRequestId);\n    }\n\n    (_a = this.reject) === null || _a === void 0 ? void 0 : _a.call(this, false);\n  }\n\n  cancel() {\n    this.stop();\n    this.tick(this.cancelTimestamp);\n  }\n\n  reverse() {\n    this.rate *= -1;\n  }\n\n  commitStyles() {}\n\n  updateDuration(duration) {\n    this.duration = duration;\n    this.totalDuration = duration * (this.repeat + 1);\n  }\n\n  get currentTime() {\n    return this.t;\n  }\n\n  set currentTime(t) {\n    if (this.pauseTime !== undefined || this.rate === 0) {\n      this.pauseTime = t;\n    } else {\n      this.startTime = performance.now() - t / this.rate;\n    }\n  }\n\n  get playbackRate() {\n    return this.rate;\n  }\n\n  set playbackRate(rate) {\n    this.rate = rate;\n  }\n\n}\n\nexport { Animation };","map":{"version":3,"sources":["C:/Users/om/OneDrive/Desktop/My_PortFolio/node_modules/@motionone/animation/dist/Animation.es.js"],"names":["noopReturn","defaults","isEasingGenerator","isEasingList","interpolate","getEasingFunction","Animation","constructor","output","keyframes","easing","duration","initialDuration","delay","endDelay","repeat","offset","direction","startTime","rate","t","cancelTimestamp","totalDuration","playState","finished","Promise","resolve","reject","custom","createAnimation","undefined","updateDuration","interpolate$1","map","tick","timestamp","_a","pauseTime","Math","max","progress","currentIteration","floor","iterationProgress","iterationIsOdd","p","min","latest","isAnimationFinished","call","frameRequestId","requestAnimationFrame","play","now","performance","pause","finish","stop","cancelAnimationFrame","cancel","reverse","commitStyles","currentTime","playbackRate"],"mappings":"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","sourcesContent":["import { noopReturn, defaults, isEasingGenerator, isEasingList, interpolate } from '@motionone/utils';\r\nimport { getEasingFunction } from './utils/easing.es.js';\r\n\r\nclass Animation {\r\n    constructor(output, keyframes = [0, 1], { easing, duration: initialDuration = defaults.duration, delay = defaults.delay, endDelay = defaults.endDelay, repeat = defaults.repeat, offset, direction = \"normal\", } = {}) {\r\n        this.startTime = null;\r\n        this.rate = 1;\r\n        this.t = 0;\r\n        this.cancelTimestamp = null;\r\n        this.easing = noopReturn;\r\n        this.duration = 0;\r\n        this.totalDuration = 0;\r\n        this.repeat = 0;\r\n        this.playState = \"idle\";\r\n        this.finished = new Promise((resolve, reject) => {\r\n            this.resolve = resolve;\r\n            this.reject = reject;\r\n        });\r\n        easing = easing || defaults.easing;\r\n        if (isEasingGenerator(easing)) {\r\n            const custom = easing.createAnimation(keyframes, () => \"0\", true);\r\n            easing = custom.easing;\r\n            if (custom.keyframes !== undefined)\r\n                keyframes = custom.keyframes;\r\n            if (custom.duration !== undefined)\r\n                initialDuration = custom.duration;\r\n        }\r\n        this.repeat = repeat;\r\n        this.easing = isEasingList(easing) ? noopReturn : getEasingFunction(easing);\r\n        this.updateDuration(initialDuration);\r\n        const interpolate$1 = interpolate(keyframes, offset, isEasingList(easing) ? easing.map(getEasingFunction) : noopReturn);\r\n        this.tick = (timestamp) => {\r\n            var _a;\r\n            // TODO: Temporary fix for OptionsResolver typing\r\n            delay = delay;\r\n            let t = 0;\r\n            if (this.pauseTime !== undefined) {\r\n                t = this.pauseTime;\r\n            }\r\n            else {\r\n                t = (timestamp - this.startTime) * this.rate;\r\n            }\r\n            this.t = t;\r\n            // Convert to seconds\r\n            t /= 1000;\r\n            // Rebase on delay\r\n            t = Math.max(t - delay, 0);\r\n            /**\r\n             * If this animation has finished, set the current time\r\n             * to the total duration.\r\n             */\r\n            if (this.playState === \"finished\" && this.pauseTime === undefined) {\r\n                t = this.totalDuration;\r\n            }\r\n            /**\r\n             * Get the current progress (0-1) of the animation. If t is >\r\n             * than duration we'll get values like 2.5 (midway through the\r\n             * third iteration)\r\n             */\r\n            const progress = t / this.duration;\r\n            // TODO progress += iterationStart\r\n            /**\r\n             * Get the current iteration (0 indexed). For instance the floor of\r\n             * 2.5 is 2.\r\n             */\r\n            let currentIteration = Math.floor(progress);\r\n            /**\r\n             * Get the current progress of the iteration by taking the remainder\r\n             * so 2.5 is 0.5 through iteration 2\r\n             */\r\n            let iterationProgress = progress % 1.0;\r\n            if (!iterationProgress && progress >= 1) {\r\n                iterationProgress = 1;\r\n            }\r\n            /**\r\n             * If iteration progress is 1 we count that as the end\r\n             * of the previous iteration.\r\n             */\r\n            iterationProgress === 1 && currentIteration--;\r\n            /**\r\n             * Reverse progress if we're not running in \"normal\" direction\r\n             */\r\n            const iterationIsOdd = currentIteration % 2;\r\n            if (direction === \"reverse\" ||\r\n                (direction === \"alternate\" && iterationIsOdd) ||\r\n                (direction === \"alternate-reverse\" && !iterationIsOdd)) {\r\n                iterationProgress = 1 - iterationProgress;\r\n            }\r\n            const p = t >= this.totalDuration ? 1 : Math.min(iterationProgress, 1);\r\n            const latest = interpolate$1(this.easing(p));\r\n            output(latest);\r\n            const isAnimationFinished = this.pauseTime === undefined &&\r\n                (this.playState === \"finished\" || t >= this.totalDuration + endDelay);\r\n            if (isAnimationFinished) {\r\n                this.playState = \"finished\";\r\n                (_a = this.resolve) === null || _a === void 0 ? void 0 : _a.call(this, latest);\r\n            }\r\n            else if (this.playState !== \"idle\") {\r\n                this.frameRequestId = requestAnimationFrame(this.tick);\r\n            }\r\n        };\r\n        this.play();\r\n    }\r\n    play() {\r\n        const now = performance.now();\r\n        this.playState = \"running\";\r\n        if (this.pauseTime !== undefined) {\r\n            this.startTime = now - this.pauseTime;\r\n        }\r\n        else if (!this.startTime) {\r\n            this.startTime = now;\r\n        }\r\n        this.cancelTimestamp = this.startTime;\r\n        this.pauseTime = undefined;\r\n        this.frameRequestId = requestAnimationFrame(this.tick);\r\n    }\r\n    pause() {\r\n        this.playState = \"paused\";\r\n        this.pauseTime = this.t;\r\n    }\r\n    finish() {\r\n        this.playState = \"finished\";\r\n        this.tick(0);\r\n    }\r\n    stop() {\r\n        var _a;\r\n        this.playState = \"idle\";\r\n        if (this.frameRequestId !== undefined) {\r\n            cancelAnimationFrame(this.frameRequestId);\r\n        }\r\n        (_a = this.reject) === null || _a === void 0 ? void 0 : _a.call(this, false);\r\n    }\r\n    cancel() {\r\n        this.stop();\r\n        this.tick(this.cancelTimestamp);\r\n    }\r\n    reverse() {\r\n        this.rate *= -1;\r\n    }\r\n    commitStyles() { }\r\n    updateDuration(duration) {\r\n        this.duration = duration;\r\n        this.totalDuration = duration * (this.repeat + 1);\r\n    }\r\n    get currentTime() {\r\n        return this.t;\r\n    }\r\n    set currentTime(t) {\r\n        if (this.pauseTime !== undefined || this.rate === 0) {\r\n            this.pauseTime = t;\r\n        }\r\n        else {\r\n            this.startTime = performance.now() - t / this.rate;\r\n        }\r\n    }\r\n    get playbackRate() {\r\n        return this.rate;\r\n    }\r\n    set playbackRate(rate) {\r\n        this.rate = rate;\r\n    }\r\n}\r\n\r\nexport { Animation };\r\n"]},"metadata":{},"sourceType":"module"}