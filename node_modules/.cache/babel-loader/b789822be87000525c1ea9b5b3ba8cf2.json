{"ast":null,"code":"import { resolveElements } from '../utils/resolve-elements.es.js';\nvar thresholds = {\n  any: 0,\n  all: 1\n};\n\nfunction inView(elementOrSelector, onStart) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      root = _ref.root,\n      rootMargin = _ref.margin,\n      _ref$amount = _ref.amount,\n      amount = _ref$amount === void 0 ? \"any\" : _ref$amount;\n\n  /**\r\n   * If this browser doesn't support IntersectionObserver, return a dummy stop function.\r\n   * Default triggering of onStart is tricky - it could be used for starting/stopping\r\n   * videos, lazy loading content etc. We could provide an option to enable a fallback, or\r\n   * provide a fallback callback option.\r\n   */\n  if (typeof IntersectionObserver === \"undefined\") {\n    return function () {};\n  }\n\n  var elements = resolveElements(elementOrSelector);\n  var activeIntersections = new WeakMap();\n\n  var onIntersectionChange = function onIntersectionChange(entries) {\n    entries.forEach(function (entry) {\n      var onEnd = activeIntersections.get(entry.target);\n      /**\r\n       * If there's no change to the intersection, we don't need to\r\n       * do anything here.\r\n       */\n\n      if (entry.isIntersecting === Boolean(onEnd)) return;\n\n      if (entry.isIntersecting) {\n        var newOnEnd = onStart(entry);\n\n        if (typeof newOnEnd === \"function\") {\n          activeIntersections.set(entry.target, newOnEnd);\n        } else {\n          observer.unobserve(entry.target);\n        }\n      } else if (onEnd) {\n        onEnd(entry);\n        activeIntersections.delete(entry.target);\n      }\n    });\n  };\n\n  var observer = new IntersectionObserver(onIntersectionChange, {\n    root: root,\n    rootMargin: rootMargin,\n    threshold: typeof amount === \"number\" ? amount : thresholds[amount]\n  });\n  elements.forEach(function (element) {\n    return observer.observe(element);\n  });\n  return function () {\n    return observer.disconnect();\n  };\n}\n\nexport { inView };","map":{"version":3,"sources":["C:/Users/om/OneDrive/Desktop/My_PortFolio/node_modules/@motionone/dom/dist/gestures/in-view.es.js"],"names":["resolveElements","thresholds","any","all","inView","elementOrSelector","onStart","root","rootMargin","margin","amount","IntersectionObserver","elements","activeIntersections","WeakMap","onIntersectionChange","entries","forEach","entry","onEnd","get","target","isIntersecting","Boolean","newOnEnd","set","observer","unobserve","delete","threshold","element","observe","disconnect"],"mappings":"AAAA,SAASA,eAAT,QAAgC,iCAAhC;AAEA,IAAMC,UAAU,GAAG;AACfC,EAAAA,GAAG,EAAE,CADU;AAEfC,EAAAA,GAAG,EAAE;AAFU,CAAnB;;AAIA,SAASC,MAAT,CAAgBC,iBAAhB,EAAmCC,OAAnC,EAA+F;AAAA,iFAAJ,EAAI;AAAA,MAAjDC,IAAiD,QAAjDA,IAAiD;AAAA,MAAnCC,UAAmC,QAA3CC,MAA2C;AAAA,yBAAvBC,MAAuB;AAAA,MAAvBA,MAAuB,4BAAd,KAAc;;AAC3F;AACJ;AACA;AACA;AACA;AACA;AACI,MAAI,OAAOC,oBAAP,KAAgC,WAApC,EAAiD;AAC7C,WAAO,YAAM,CAAG,CAAhB;AACH;;AACD,MAAMC,QAAQ,GAAGZ,eAAe,CAACK,iBAAD,CAAhC;AACA,MAAMQ,mBAAmB,GAAG,IAAIC,OAAJ,EAA5B;;AACA,MAAMC,oBAAoB,GAAG,SAAvBA,oBAAuB,CAACC,OAAD,EAAa;AACtCA,IAAAA,OAAO,CAACC,OAAR,CAAgB,UAACC,KAAD,EAAW;AACvB,UAAMC,KAAK,GAAGN,mBAAmB,CAACO,GAApB,CAAwBF,KAAK,CAACG,MAA9B,CAAd;AACA;AACZ;AACA;AACA;;AACY,UAAIH,KAAK,CAACI,cAAN,KAAyBC,OAAO,CAACJ,KAAD,CAApC,EACI;;AACJ,UAAID,KAAK,CAACI,cAAV,EAA0B;AACtB,YAAME,QAAQ,GAAGlB,OAAO,CAACY,KAAD,CAAxB;;AACA,YAAI,OAAOM,QAAP,KAAoB,UAAxB,EAAoC;AAChCX,UAAAA,mBAAmB,CAACY,GAApB,CAAwBP,KAAK,CAACG,MAA9B,EAAsCG,QAAtC;AACH,SAFD,MAGK;AACDE,UAAAA,QAAQ,CAACC,SAAT,CAAmBT,KAAK,CAACG,MAAzB;AACH;AACJ,OARD,MASK,IAAIF,KAAJ,EAAW;AACZA,QAAAA,KAAK,CAACD,KAAD,CAAL;AACAL,QAAAA,mBAAmB,CAACe,MAApB,CAA2BV,KAAK,CAACG,MAAjC;AACH;AACJ,KArBD;AAsBH,GAvBD;;AAwBA,MAAMK,QAAQ,GAAG,IAAIf,oBAAJ,CAAyBI,oBAAzB,EAA+C;AAC5DR,IAAAA,IAAI,EAAJA,IAD4D;AAE5DC,IAAAA,UAAU,EAAVA,UAF4D;AAG5DqB,IAAAA,SAAS,EAAE,OAAOnB,MAAP,KAAkB,QAAlB,GAA6BA,MAA7B,GAAsCT,UAAU,CAACS,MAAD;AAHC,GAA/C,CAAjB;AAKAE,EAAAA,QAAQ,CAACK,OAAT,CAAiB,UAACa,OAAD;AAAA,WAAaJ,QAAQ,CAACK,OAAT,CAAiBD,OAAjB,CAAb;AAAA,GAAjB;AACA,SAAO;AAAA,WAAMJ,QAAQ,CAACM,UAAT,EAAN;AAAA,GAAP;AACH;;AAED,SAAS5B,MAAT","sourcesContent":["import { resolveElements } from '../utils/resolve-elements.es.js';\r\n\r\nconst thresholds = {\r\n    any: 0,\r\n    all: 1,\r\n};\r\nfunction inView(elementOrSelector, onStart, { root, margin: rootMargin, amount = \"any\" } = {}) {\r\n    /**\r\n     * If this browser doesn't support IntersectionObserver, return a dummy stop function.\r\n     * Default triggering of onStart is tricky - it could be used for starting/stopping\r\n     * videos, lazy loading content etc. We could provide an option to enable a fallback, or\r\n     * provide a fallback callback option.\r\n     */\r\n    if (typeof IntersectionObserver === \"undefined\") {\r\n        return () => { };\r\n    }\r\n    const elements = resolveElements(elementOrSelector);\r\n    const activeIntersections = new WeakMap();\r\n    const onIntersectionChange = (entries) => {\r\n        entries.forEach((entry) => {\r\n            const onEnd = activeIntersections.get(entry.target);\r\n            /**\r\n             * If there's no change to the intersection, we don't need to\r\n             * do anything here.\r\n             */\r\n            if (entry.isIntersecting === Boolean(onEnd))\r\n                return;\r\n            if (entry.isIntersecting) {\r\n                const newOnEnd = onStart(entry);\r\n                if (typeof newOnEnd === \"function\") {\r\n                    activeIntersections.set(entry.target, newOnEnd);\r\n                }\r\n                else {\r\n                    observer.unobserve(entry.target);\r\n                }\r\n            }\r\n            else if (onEnd) {\r\n                onEnd(entry);\r\n                activeIntersections.delete(entry.target);\r\n            }\r\n        });\r\n    };\r\n    const observer = new IntersectionObserver(onIntersectionChange, {\r\n        root,\r\n        rootMargin,\r\n        threshold: typeof amount === \"number\" ? amount : thresholds[amount],\r\n    });\r\n    elements.forEach((element) => observer.observe(element));\r\n    return () => observer.disconnect();\r\n}\r\n\r\nexport { inView };\r\n"]},"metadata":{},"sourceType":"module"}